From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: lordpipe <lordpipe@protonmail.com>
Date: Thu, 18 Aug 2022 12:00:40 -0600
Subject: [PATCH] Soul sand is freezy

Makes it possible to wedge a boat into soul sand without it falling.

diff --git a/src/main/java/io/papermc/paper/util/CollisionUtil.java b/src/main/java/io/papermc/paper/util/CollisionUtil.java
index a87f6380b2c387fb0cdd40d5087b5c93492e3c88..777a9bc2dda2f80a5dea8bfcce31a85b9af06cbf 100644
--- a/src/main/java/io/papermc/paper/util/CollisionUtil.java
+++ b/src/main/java/io/papermc/paper/util/CollisionUtil.java
@@ -38,6 +38,12 @@ public final class CollisionUtil {
     public static final long KNOWN_UNKNOWN_BLOCK = 0b10; // must read the actual block state for info
     public static final long KNOWN_SPECIAL_BLOCK = 0b11; // caller must check this block for special collisions
 
+    // this is ugly :D
+    // instead of doing multiple return values, we just stick this onto the static class object so that the results can
+    // propagate to net.minecraft.world.entity.Entity. this way, we don't have to change a bunch of function calls
+    // just to make soul sand a motion-freezing block
+    public static boolean lastBlockIsFreezy = false;
+
     public static boolean isSpecialCollidingBlock(final net.minecraft.world.level.block.state.BlockBehaviour.BlockStateBase block) {
         return block.shapeExceedsCube() || block.getBlock() == Blocks.MOVING_PISTON;
     }
@@ -407,6 +413,7 @@ public final class CollisionUtil {
                                                                   final List<AABB> into, final boolean loadChunks, final boolean collidesWithUnloaded,
                                                                   final boolean checkBorder, final boolean checkOnly, final BiPredicate<BlockState, BlockPos> predicate) {
         boolean ret = false;
+        lastBlockIsFreezy = false;
 
         if (checkBorder) {
             if (CollisionUtil.isAlmostCollidingOnBorder(getter.getWorldBorder(), aabb)) {
@@ -631,10 +638,12 @@ public final class CollisionUtil {
 
                                         if (checkOnly) {
                                             if (voxelshape3.intersects(aabb)) {
+                                                lastBlockIsFreezy = blockData.getBlock() instanceof net.minecraft.world.level.block.SoulSandBlock;
                                                 return true;
                                             }
                                         } else {
                                             ret |= addBoxesToIfIntersects(voxelshape3, aabb, into);
+                                            lastBlockIsFreezy |= blockData.getBlock() instanceof net.minecraft.world.level.block.SoulSandBlock;
                                         }
                                     }
                                 }
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index f925a8d550ecbf2044a37bfe58b30d6578c5f6af..f06df6cd5d7d28013c18d61ccadc0133a19a68bb 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -1383,6 +1383,13 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
             io.papermc.paper.util.CollisionUtil.getCollisions(world, this, collisionBox, potentialCollisions, false, true,
                 false, false, null, null);
 
+            if ((this instanceof net.minecraft.world.entity.vehicle.Boat
+                    || this instanceof net.minecraft.world.entity.vehicle.Minecart)
+                    && io.papermc.paper.util.CollisionUtil.lastBlockIsFreezy) {
+                // block is "freezy" - do not allow any motion changes while inside of it
+                return new Vec3(0.0, 0.0, 0.0);
+            }
+
             if (io.papermc.paper.util.CollisionUtil.isCollidingWithBorderEdge(world.getWorldBorder(), collisionBox)) {
                 io.papermc.paper.util.CollisionUtil.addBoxesToIfIntersects(world.getWorldBorder().getCollisionShape(), collisionBox, potentialCollisions);
             }
