From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: lordpipe <lordpipe@protonmail.com>
Date: Mon, 26 Dec 2022 06:39:00 -0700
Subject: [PATCH] Soul sand is freezy

Makes it possible to wedge a boat into soul sand without it falling.

diff --git a/src/main/java/io/papermc/paper/util/CollisionUtil.java b/src/main/java/io/papermc/paper/util/CollisionUtil.java
index a87f6380b2c387fb0cdd40d5087b5c93492e3c88..777a9bc2dda2f80a5dea8bfcce31a85b9af06cbf 100644
--- a/src/main/java/io/papermc/paper/util/CollisionUtil.java
+++ b/src/main/java/io/papermc/paper/util/CollisionUtil.java
@@ -38,6 +38,12 @@ public final class CollisionUtil {
     public static final long KNOWN_UNKNOWN_BLOCK = 0b10; // must read the actual block state for info
     public static final long KNOWN_SPECIAL_BLOCK = 0b11; // caller must check this block for special collisions
 
+    // this is ugly :D
+    // instead of doing multiple return values, we just stick this onto the static class object so that the results can
+    // propagate to net.minecraft.world.entity.Entity. this way, we don't have to change a bunch of function calls
+    // just to make soul sand a motion-freezing block
+    public static boolean lastBlockIsFreezy = false;
+
     public static boolean isSpecialCollidingBlock(final net.minecraft.world.level.block.state.BlockBehaviour.BlockStateBase block) {
         return block.shapeExceedsCube() || block.getBlock() == Blocks.MOVING_PISTON;
     }
@@ -407,6 +413,7 @@ public final class CollisionUtil {
                                                                   final List<AABB> into, final boolean loadChunks, final boolean collidesWithUnloaded,
                                                                   final boolean checkBorder, final boolean checkOnly, final BiPredicate<BlockState, BlockPos> predicate) {
         boolean ret = false;
+        lastBlockIsFreezy = false;
 
         if (checkBorder) {
             if (CollisionUtil.isAlmostCollidingOnBorder(getter.getWorldBorder(), aabb)) {
@@ -631,10 +638,12 @@ public final class CollisionUtil {
 
                                         if (checkOnly) {
                                             if (voxelshape3.intersects(aabb)) {
+                                                lastBlockIsFreezy = blockData.getBlock() instanceof net.minecraft.world.level.block.SoulSandBlock;
                                                 return true;
                                             }
                                         } else {
                                             ret |= addBoxesToIfIntersects(voxelshape3, aabb, into);
+                                            lastBlockIsFreezy |= blockData.getBlock() instanceof net.minecraft.world.level.block.SoulSandBlock;
                                         }
                                     }
                                 }
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index 1eaab1f6923e6aa34b643293347348e5cc19af3c..288ad5d30644e3c41d6bb4437b9f6425393e211e 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -1392,6 +1392,15 @@ public abstract class Entity implements Nameable, EntityAccess, CommandSource {
             io.papermc.paper.util.CollisionUtil.getCollisions(world, this, collisionBox, potentialCollisions, false, this.level.paperConfig().chunks.preventMovingIntoUnloadedChunks,
                 false, false, null, null);
 
+            double yMod = this.getY() % 1.0;
+            if ((this instanceof net.minecraft.world.entity.vehicle.Boat
+                    || this instanceof net.minecraft.world.entity.vehicle.Minecart)
+                    && yMod != 0.0 && yMod < 0.875
+                    && io.papermc.paper.util.CollisionUtil.lastBlockIsFreezy) {
+                // block is "freezy" - do not allow any motion changes while inside of it
+                return new Vec3(0.0, 0.0, 0.0);
+            }
+
             if (collidingWithWorldBorder = io.papermc.paper.util.CollisionUtil.isCollidingWithBorderEdge(world.getWorldBorder(), collisionBox)) { // Paper - this line *is* correct, ignore the IDE warning about assignments being used as a condition
                 io.papermc.paper.util.CollisionUtil.addBoxesToIfIntersects(world.getWorldBorder().getCollisionShape(), collisionBox, potentialCollisions);
             }
